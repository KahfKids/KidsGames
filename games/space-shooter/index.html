<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Space Shooter</title>
    <!-- KidsGames PWA Support -->
    <link rel="manifest" href="/KidsGames/manifest.json" />
    <meta name="theme-color" content="#4f391a" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <link rel="apple-touch-icon" href="/KidsGames/icons/icon-192x192.png" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <style>
      * {
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #111;
        overflow: hidden;
        position: fixed;
        width: 100%;
      }

      #gameArea {
        border: 2px solid white;
        background: black;
        cursor: crosshair;
        max-width: 100%;
        max-height: 80vh;
        touch-action: none;
      }

      .score {
        position: fixed;
        top: 10px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        z-index: 100;
      }

      .instructions {
        position: fixed;
        top: 40px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        font-size: 14px;
        z-index: 100;
      }

      #restartButton {
        display: none;
        position: fixed;
        padding: 10px 20px;
        font-size: 18px;
        background: lime;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-family: Arial, sans-serif;
        z-index: 100;
        left: 50%;
        transform: translateX(-50%);
      }

      
      /* Swipe area for mobile controls */
      .swipe-area {
        position: fixed;
        bottom: 20px;
        left: 20px;
        right: 20px;
        width: auto;
        height: 80px;
        background: rgba(255, 255, 255, 0.2);
        border: 2px dashed rgba(255, 255, 255, 0.6);
        border-radius: 15px;
        display: flex;
        justify-content: center;
        align-items: center;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        pointer-events: auto;
        z-index: 1000;
        transition: all 0.2s ease;
      }

      .swipe-area.swipe-active {
        background: rgba(255, 255, 255, 0.4);
        border-color: rgba(255, 255, 255, 0.9);
        transform: scale(1.02);
      }

      .swipe-instructions {
        position: absolute;
        color: white;
        font-size: 14px;
        font-weight: bold;
        font-family: Arial, sans-serif;
        text-align: center;
        pointer-events: none;
        opacity: 0.9;
        z-index: 1001;
        animation: swipePulse 2s infinite ease-in-out;
        left: 50%;
        transform: translateX(-50%);
      }

      .swipe-instructions.hidden {
        display: none;
      }

      @keyframes swipePulse {
        0%, 100% { transform: translateX(-50%) translateY(0) scale(1); opacity: 0.9; }
        50% { transform: translateX(-50%) translateY(-3px) scale(1.05); opacity: 1; }
      }

      .swipe-indicator {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(255, 255, 255, 0.4);
        font-size: 12px;
        font-family: Arial, sans-serif;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .swipe-indicator.hidden {
        opacity: 0;
      }

      .control-button {
        width: 70px;
        height: 70px;
        background: rgba(255, 255, 255, 0.3);
        border: 3px solid white;
        border-radius: 12px;
        color: white;
        font-size: 28px;
        cursor: pointer;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        position: absolute;
        z-index: 1001; /* Higher than swipe area */
        transition: all 0.1s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .control-button:active,
      .control-button.pressed {
        transform: scale(0.95);
        background: rgba(255, 255, 255, 0.5);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      
      @media (max-width: 1024px) {
        /* #mobileControls {
          display: block;
        } */

        /* #gameArea {
          width: 100%;
          height: auto;
        } */

        .instructions {
          font-size: 12px;
        }
      }
    </style>
  </head>
  <body>
    <div class="score">Score: <span id="scoreElement">0</span></div>
    <div class="instructions">
      Use arrows to move, SHOOT button to fire<br />
      Or use mouse/touch controls
    </div>
    <svg
      id="gameArea"
      width="600"
      height="400"
      preserveAspectRatio="xMidYMid meet"
      viewBox="0 0 600 400"
    >
      <defs>
        <!-- Player Spaceship -->
        <g id="playerShip">
          <path
            d="M0,-15 L-5,-5 L-20,10 L-15,15 L-5,12 L0,15 L5,12 L15,15 L20,10 L5,-5 Z"
            fill="lime"
          />
          <ellipse cx="0" cy="-5" rx="3" ry="5" fill="#00ff00" />
          <rect x="-15" y="10" width="6" height="3" fill="#00cc00" />
          <rect x="9" y="10" width="6" height="3" fill="#00cc00" />
          <circle cx="-12" cy="11.5" r="2" fill="#ffff00" opacity="0.7" />
          <circle cx="12" cy="11.5" r="2" fill="#ffff00" opacity="0.7" />
        </g>

        <!-- Enemy Ship -->
        <g id="enemyShip">
          <path d="M-15,-15 L15,-15 L15,-5 L5,15 L-5,15 L-15,-5 Z" fill="red" />
          <circle cx="-8" cy="-5" r="3" fill="white" />
          <circle cx="8" cy="-5" r="3" fill="white" />
        </g>

        <!-- Bullet -->
        <rect id="bullet" width="8" height="20" fill="#00ff00" />
      </defs>
    </svg>
    <!-- Swipe area for mobile -->
    <div class="swipe-area" id="swipeArea">
      <div class="swipe-instructions" id="swipeInstructions">
        <p><i class="fas fa-hand-point-up"></i></p>
        <p>Swipe Here</p>
      </div>
      <div class="swipe-indicator" id="swipeIndicator">← Swipe →</div>
    </div>

        <button id="restartButton">Restart Game</button>
    <script>
      const svg = document.getElementById("gameArea");
      const scoreElement = document.getElementById("scoreElement");
      const restartButton = document.getElementById("restartButton");
      const swipeArea = document.getElementById("swipeArea");
      const swipeInstructions = document.getElementById("swipeInstructions");
      const swipeIndicator = document.getElementById("swipeIndicator");

      // Get SVG dimensions and scaling
      let svgRect = svg.getBoundingClientRect();
      const viewBox = {
        width: 600,
        height: 400,
      };

      let player = {
        x: 300,
        y: 370,
        element: null,
        reloadTime: 200,
        speed: 5,
      };

      let bullet = {
        x: 0,
        y: 0,
        element: null,
        active: false,
        speed: 10,
        width: 8,
        height: 20,
      };

      let lastShotTime = 0;
      let enemies = [];
      const enemyRows = 3;
      const enemiesPerRow = 8;
      const enemyWidth = 30;
      const enemyHeight = 30;
      const enemyPadding = 20;

      let score = 0;
      let gameLoop;
      let moveRight = true;
      let enemySpeed = 1;
      let gameIsOver = false;

      // Control states
      let isLeftPressed = false;
      let isRightPressed = false;

      // Keyboard control states
      let isKeyboardLeft = false;
      let isKeyboardRight = false;

      // Swipe control variables
      let touchStartX = 0;
      let swipeActive = false;
      let playerSwipeVelocity = 0;
      let swipeAcceleration = 1.5; // Increased for better responsiveness
      let swipeFriction = 0.88; // Less friction for longer momentum
      let maxSwipeVelocity = 20; // Increased for faster movement
      let playerTargetX = player.x; // Add this for smooth swipe movement
      let hasInteracted = false;

      // Auto-shooting variables
      let autoShootInterval = null;
      let autoShootRate = 500; // Shoot every 500ms (2 shots per second)

      // Input mode detection
      let inputMode = 'mixed'; // 'keyboard', 'touch', 'mouse', 'mixed'

      function createSVGElement(type, attributes) {
        const elem = document.createElementNS(
          "http://www.w3.org/2000/svg",
          type
        );
        for (let key in attributes) {
          elem.setAttribute(key, attributes[key]);
        }
        return elem;
      }

      function getScaledPosition(clientX) {
        const rect = svg.getBoundingClientRect();
        const scale = viewBox.width / rect.width;
        return (clientX - rect.left) * scale;
      }

      function initGame() {
        while (svg.lastChild) {
          if (svg.lastChild.tagName === "defs") break;
          svg.removeChild(svg.lastChild);
        }

        enemies = [];
        score = 0;
        moveRight = true;
        enemySpeed = 1;
        gameIsOver = false;
        scoreElement.textContent = "0";
        restartButton.style.display = "none";
        lastShotTime = 0;

        // Reset swipe variables
        playerSwipeVelocity = 0;
        swipeActive = false;
        playerTargetX = 300;
        hasInteracted = false;

        player.x = 300;
        player.y = 370;
        player.element = createSVGElement("use", {
          href: "#playerShip",
          transform: `translate(${player.x},${player.y})`,
        });
        svg.appendChild(player.element);

        createEnemies();

        // Start auto-shooting
        startAutoShoot();

        if (gameLoop) clearInterval(gameLoop);
        gameLoop = setInterval(update, 1000 / 60);
      }

      function createEnemies() {
        for (let row = 0; row < enemyRows; row++) {
          for (let col = 0; col < enemiesPerRow; col++) {
            const enemy = {
              x: col * (enemyWidth + enemyPadding) + enemyPadding + enemyWidth,
              y:
                row * (enemyHeight + enemyPadding) + enemyPadding + enemyHeight,
              alive: true,
              element: createSVGElement("use", {
                href: "#enemyShip",
                transform: `translate(${
                  col * (enemyWidth + enemyPadding) + enemyPadding + enemyWidth
                },
                                                ${
                                                  row *
                                                    (enemyHeight +
                                                      enemyPadding) +
                                                  enemyPadding +
                                                  enemyHeight
                                                })`,
              }),
            };
            svg.appendChild(enemy.element);
            enemies.push(enemy);
          }
        }
      }

      function shoot() {
        const currentTime = Date.now();
        if (
          !bullet.active &&
          !gameIsOver &&
          currentTime - lastShotTime >= player.reloadTime
        ) {
          bullet.active = true;
          bullet.x = player.x;
          bullet.y = player.y - 10;
          bullet.element = createSVGElement("use", {
            href: "#bullet",
            transform: `translate(${bullet.x - bullet.width / 2},${bullet.y})`,
          });
          svg.appendChild(bullet.element);
          lastShotTime = currentTime;
        }
      }

      function startAutoShoot() {
        if (autoShootInterval) return; // Already shooting

        autoShootInterval = setInterval(() => {
          if (!gameIsOver) {
            shoot();
          }
        }, autoShootRate);
      }

      function stopAutoShoot() {
        if (autoShootInterval) {
          clearInterval(autoShootInterval);
          autoShootInterval = null;
        }
      }

      function moveEnemies() {
        let touchedEdge = false;

        enemies.forEach((enemy) => {
          if (enemy.alive) {
            if (moveRight) {
              enemy.x += enemySpeed;
              if (enemy.x + enemyWidth / 2 > viewBox.width) touchedEdge = true;
            } else {
              enemy.x -= enemySpeed;
              if (enemy.x - enemyWidth / 2 < 0) touchedEdge = true;
            }
            enemy.element.setAttribute(
              "transform",
              `translate(${enemy.x},${enemy.y})`
            );
          }
        });

        if (touchedEdge) {
          moveRight = !moveRight;
          enemies.forEach((enemy) => {
            if (enemy.alive) {
              enemy.y += 20;
            }
          });
        }
      }

      function checkCollisions() {
        if (bullet.active) {
          enemies.forEach((enemy) => {
            if (enemy.alive) {
              const dx = bullet.x - enemy.x;
              const dy = bullet.y - enemy.y;
              if (
                Math.abs(dx) < enemyWidth / 2 + bullet.width / 2 &&
                Math.abs(dy) < enemyHeight / 2 + bullet.height / 2
              ) {
                enemy.alive = false;
                enemy.element.remove();
                bullet.active = false;
                bullet.element.remove();
                score += 10;
                scoreElement.textContent = score;
                checkWinCondition();
              }
            }
          });
        }
      }

      function checkWinCondition() {
        const allEnemiesDefeated = enemies.every((enemy) => !enemy.alive);
        if (allEnemiesDefeated) {
          clearInterval(gameLoop);
          gameIsOver = true;
          stopAutoShoot();

          const winText = createSVGElement("text", {
            x: "300",
            y: "200",
            "text-anchor": "middle",
            "font-size": "48",
            fill: "white",
            "font-family": "Arial",
          });
          winText.textContent = "Congratulations, You win!";
          svg.appendChild(winText);

          restartButton.style.display = "block";
          restartButton.style.top = `${
            svg.getBoundingClientRect().top + 250
          }px`;
        }
      }

      function gameOver() {
        enemies.forEach((enemy) => {
          if (enemy.alive && enemy.y + enemyHeight / 2 >= player.y - 10) {
            clearInterval(gameLoop);
            gameIsOver = true;
            stopAutoShoot();

            const gameOverText = createSVGElement("text", {
              x: "300",
              y: "200",
              "text-anchor": "middle",
              "font-size": "48",
              fill: "white",
              "font-family": "Arial",
            });
            gameOverText.textContent = "GAME OVER";
            svg.appendChild(gameOverText);

            restartButton.style.display = "block";
            restartButton.style.top = `${
              svg.getBoundingClientRect().top + 250
            }px`;
          }
        });
      }

      function update() {
        if (!gameIsOver) {
          // Handle movement from all input sources
          let moveLeft = isLeftPressed || isKeyboardLeft;
          let moveRight = isRightPressed || isKeyboardRight;

          if (moveLeft) {
            playerSwipeVelocity = -player.speed;
          } else if (moveRight) {
            playerSwipeVelocity = player.speed;
          } else if (swipeActive || playerSwipeVelocity !== 0) {
            // Apply swipe physics
            playerSwipeVelocity *= swipeFriction;

            if (Math.abs(playerSwipeVelocity) < 0.1) {
              playerSwipeVelocity = 0;
            }
          }

          // Apply swipe velocity to player position
          if (playerSwipeVelocity !== 0) {
            // Direct position update with velocity for immediate response
            player.x += playerSwipeVelocity;
            player.x = Math.max(20, Math.min(viewBox.width - 20, player.x));
          } else {
            // Regular button movement
            if (moveLeft) {
              player.x = Math.max(20, player.x - player.speed);
            }
            if (moveRight) {
              player.x = Math.min(viewBox.width - 20, player.x + player.speed);
            }
          }
        }

        player.element.setAttribute(
          "transform",
          `translate(${player.x},${player.y})`
        );

        if (bullet.active) {
          bullet.y -= bullet.speed;
          bullet.element.setAttribute(
            "transform",
            `translate(${bullet.x - bullet.width / 2},${bullet.y})`
          );

          if (bullet.y < 0) {
            bullet.active = false;
            bullet.element.remove();
          }
        }

        moveEnemies();
        checkCollisions();
        gameOver();
      }

      // Input mode detection
      function detectInputMode(type) {
        if (type === 'keyboard') {
          if (inputMode !== 'keyboard') {
            inputMode = 'keyboard';
            updateControlInstructions();
          }
        } else if (type === 'touch') {
          if (inputMode !== 'touch') {
            inputMode = 'touch';
            updateControlInstructions();
          }
        } else if (type === 'mouse') {
          if (inputMode === 'keyboard') {
            inputMode = 'mixed';
            updateControlInstructions();
          }
        }
      }

      // Update control instructions based on input mode
      function updateControlInstructions() {
        const instructions = document.querySelector('.instructions');
        if (inputMode === 'keyboard') {
          instructions.innerHTML = 'Use Arrow Keys/WASD to move, Auto-shooting enabled';
        } else if (inputMode === 'touch') {
          instructions.innerHTML = 'Swipe in the swipe area to move<br>Auto-shooting enabled<br>Or touch/drag on game area';
        } else {
          instructions.innerHTML = 'Use arrows/WASD to move or swipe<br>Auto-shooting enabled';
        }
      }

      // Keyboard event handlers
      function handleKeyDown(e) {
        if (gameIsOver) return;

        detectInputMode('keyboard');

        switch(e.key) {
          case 'ArrowLeft':
          case 'a':
          case 'A':
            e.preventDefault();
            isKeyboardLeft = true;
            break;
          case 'ArrowRight':
          case 'd':
          case 'D':
            e.preventDefault();
            isKeyboardRight = true;
            break;
          // Removed space/enter shooting since we have auto-shoot
        }
      }

      function handleKeyUp(e) {
        switch(e.key) {
          case 'ArrowLeft':
          case 'a':
          case 'A':
            isKeyboardLeft = false;
            break;
          case 'ArrowRight':
          case 'd':
          case 'D':
            isKeyboardRight = false;
            break;
        }
      }

      // Mouse/Touch movement handler
      function handleMove(e) {
        if (gameIsOver) return;

        const isTouch = e.type.includes("touch");
        if (isTouch) {
          detectInputMode('touch');
        } else {
          detectInputMode('mouse');
        }

        // Only use mouse/touch movement if keyboard is not active
        if (!isKeyboardLeft && !isKeyboardRight) {
          const clientX = isTouch ? e.touches[0].clientX : e.clientX;
          const scaledX = getScaledPosition(clientX);
          player.x = Math.max(20, Math.min(viewBox.width - 20, scaledX));
        }
      }

      
      // Swipe Area Event Listeners
      swipeArea.addEventListener("touchstart", (e) => {
        if (gameIsOver) return;

        const touch = e.touches[0];
        touchStartX = touch.clientX;
        swipeActive = true;
        playerTargetX = undefined;

        // Visual feedback
        swipeArea.classList.add('swipe-active');
        swipeIndicator.classList.add('hidden');

        // Hide instructions on first interaction
        if (!hasInteracted) {
          hasInteracted = true;
          swipeInstructions.classList.add('hidden');
        }

        detectInputMode('touch');
      }, { passive: true });

      swipeArea.addEventListener("touchmove", (e) => {
        if (!swipeActive || gameIsOver) return;

        const touch = e.touches[0];
        const touchX = touch.clientX;
        const deltaX = touchX - touchStartX;

        // Apply velocity based on swipe speed with improved physics
        const swipeVelocity = deltaX * swipeAcceleration;

        // Add to existing velocity for momentum-based movement
        playerSwipeVelocity += swipeVelocity;

        // Apply limits
        playerSwipeVelocity = Math.max(-maxSwipeVelocity, Math.min(maxSwipeVelocity, playerSwipeVelocity));

        // Update touch start for continuous swipe
        touchStartX = touchX;
      }, { passive: true });

      swipeArea.addEventListener("touchend", (e) => {
        if (!swipeActive) return;

        swipeActive = false;
        swipeArea.classList.remove('swipe-active');

        // Allow momentum to continue player movement
      }, { passive: true });

      swipeArea.addEventListener("touchcancel", (e) => {
        if (!swipeActive) return;

        swipeActive = false;
        swipeArea.classList.remove('swipe-active');
        playerSwipeVelocity = 0;
      }, { passive: true });

      // Mouse fallback for swipe area (for desktop testing)
      swipeArea.addEventListener("mousedown", (e) => {
        if (gameIsOver) return;

        touchStartX = e.clientX;
        swipeActive = true;
        playerTargetX = undefined;

        // Visual feedback
        swipeArea.classList.add('swipe-active');
        swipeIndicator.classList.add('hidden');

        // Hide instructions on first interaction
        if (!hasInteracted) {
          hasInteracted = true;
          swipeInstructions.classList.add('hidden');
        }

        detectInputMode('mouse');
        e.preventDefault();
      });

      swipeArea.addEventListener("mousemove", (e) => {
        if (!swipeActive || gameIsOver) return;

        const deltaX = e.clientX - touchStartX;

        // Apply velocity based on mouse drag speed with improved physics
        const swipeVelocity = deltaX * swipeAcceleration;

        // Add to existing velocity for momentum-based movement
        playerSwipeVelocity += swipeVelocity;

        // Apply limits
        playerSwipeVelocity = Math.max(-maxSwipeVelocity, Math.min(maxSwipeVelocity, playerSwipeVelocity));

        // Update touch start for continuous drag
        touchStartX = e.clientX;
      });

      swipeArea.addEventListener("mouseup", (e) => {
        if (!swipeActive) return;

        swipeActive = false;
        swipeArea.classList.remove('swipe-active');

        // Allow momentum to continue player movement
        e.preventDefault();
      });

      swipeArea.addEventListener("mouseleave", (e) => {
        if (!swipeActive) return;

        swipeActive = false;
        swipeArea.classList.remove('swipe-active');
        playerSwipeVelocity = 0;
      });

      
      // Haptic feedback function
      function triggerHaptic() {
        if ('vibrate' in navigator) {
          navigator.vibrate(10);
        }
      }

      
      // Keyboard Event Listeners
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);

      // Mouse/Touch Event Listeners
      svg.addEventListener("mousemove", handleMove);
      svg.addEventListener("touchmove", (e) => {
        // Only handle touch if it starts on the SVG, not on buttons
        if (e.target === svg) {
          handleMove(e);
        }
      });
      svg.addEventListener("touchstart", (e) => {
        // Only handle touch if it starts on the SVG, not on buttons
        if (e.target === svg) {
          handleMove(e);
        }
      });
      restartButton.addEventListener("click", initGame);
      restartButton.addEventListener("touchstart", (e) => {
        e.preventDefault();
        initGame();
      });

      // Prevent default touch behaviors
      document.addEventListener("touchmove", (e) => e.preventDefault(), {
        passive: false,
      });

      // Handle window resize
      window.addEventListener("resize", () => {
        svgRect = svg.getBoundingClientRect();
      });

      // Initial game start
      initGame();

      // Initialize control instructions
      updateControlInstructions();
    </script>

    <!-- KidsGames PWA Service Worker -->
    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/KidsGames/sw.js")
            .then((registration) => {
              console.log("[PWA] Service Worker registered for free game");
            })
            .catch((error) => {
              console.log("[PWA] Service Worker registration failed:", error);
            });
        });
      }
    </script>
  </body>
</html>
