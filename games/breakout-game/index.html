<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Breakout Game</title>
    <!-- KidsGames PWA Support -->
    <link rel="manifest" href="/KidsGames/manifest.json" />
    <meta name="theme-color" content="#4f391a" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <link rel="apple-touch-icon" href="/KidsGames/icons/icon-192x192.png" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <style>
      /* General body styling */
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        background: linear-gradient(
          135deg,
          #2a2a72,
          #009ffd
        ); /* Cool gradient background */
        font-family: "Inter", sans-serif; /* Inter font for modern look */
        color: #fff;
        overflow: hidden; /* Prevent scrollbars */
        padding: 20px;
        box-sizing: border-box;
      }

      /* Game container styling */
      .game-container {
        background-color: #1a1a40; /* Darker background for game area */
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); /* Stronger shadow for depth */
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        max-width: 90vw; /* Max width for responsiveness */
        width: 800px; /* Base width */
        box-sizing: border-box;
        position: relative;
        overflow: hidden; /* Ensure nothing overflows */
      }

      /* Game title */
      h1 {
        font-size: 2.5em;
        margin-bottom: 20px;
        color: #fff;
        text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
      }

      /* Game Canvas styling */
      canvas {
        background-color: #0d0d2b; /* Even darker canvas background */
        border: 3px solid #009ffd; /* Border matching gradient */
        border-radius: 10px;
        display: block;
        touch-action: none; /* Disable default touch actions */
        box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5); /* Inner shadow for canvas */
        max-width: 100%; /* Make canvas fluid width but don't stretch */
        max-height: 70vh; /* Increase canvas height limit for better gameplay */
        image-rendering: crisp-edges; /* Better pixel scaling */
        image-rendering: pixelated; /* Fallback for older browsers */
      }

      /* Game information display */
      .game-info {
        display: flex;
        justify-content: space-between;
        width: 100%;
        padding: 10px 0;
        font-size: 1.2em;
        color: #ccc;
        margin-bottom: 10px;
      }

      /* Control buttons styling */
      .controls {
        margin-top: 20px;
        display: flex;
        gap: 15px; /* Spacing between buttons */
        flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        justify-content: center;
      }

      .game-button {
        background: linear-gradient(
          180deg,
          #00c6ff,
          #0072ff
        ); /* Gradient for buttons */
        border: none;
        color: white;
        padding: 12px 25px;
        text-align: center;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.1em;
        font-weight: bold;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease; /* Smooth transitions for hover/active */
        box-shadow: 0 4px 15px rgba(0, 114, 255, 0.4);
        gap: 8px; /* Space between icon and text */
      }

      .game-button:hover {
        background: linear-gradient(180deg, #00e0ff, #0088ff);
        transform: translateY(-2px); /* Slight lift on hover */
        box-shadow: 0 6px 20px rgba(0, 114, 255, 0.6);
      }

      .game-button:active {
        transform: translateY(0); /* Press effect */
        box-shadow: 0 2px 10px rgba(0, 114, 255, 0.3);
        background: linear-gradient(180deg, #0072ff, #00c6ff);
      }

      .game-button i {
        margin-right: 5px; /* Space between icon and text */
      }

      /* Touch controls styling */
      .touch-controls {
        position: relative;
        margin-top: 30px; /* Add space above controls */
        display: none; /* Hidden by default on desktop */
        gap: 20px;
        z-index: 100;
        justify-content: center;
        width: 100%;
      }

      .touch-button {
        width: 60px;
        height: 60px;
        min-width: 60px; /* Ensure minimum touch target size */
        min-height: 60px;
        background: linear-gradient(180deg, rgba(0, 198, 255, 0.8), rgba(0, 114, 255, 0.8));
        border: 2px solid #009ffd;
        border-radius: 50%;
        color: white;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 15px rgba(0, 114, 255, 0.4);
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        touch-action: manipulation; /* Improve touch responsiveness */
      }

      .touch-button:active,
      .touch-button.active {
        transform: scale(0.95);
        background: linear-gradient(180deg, rgba(0, 224, 255, 0.9), rgba(0, 136, 255, 0.9));
        box-shadow: 0 2px 10px rgba(0, 114, 255, 0.6);
      }

      .touch-button-left {
        left: -10px;
      }

      .touch-button-right {
        right: -10px;
      }

      /* Show touch controls on mobile devices */
      @media (max-width: 768px), (pointer: coarse) {
        .touch-controls {
          display: flex;
        }
      }

      /* Message box styling */
      .message-box {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(
          0,
          0,
          0,
          0.85
        ); /* Semi-transparent dark background */
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.7);
        text-align: center;
        font-size: 1.5em;
        color: #fff;
        z-index: 1000; /* Bring to front */
        display: none; /* Hidden by default */
        border: 2px solid #009ffd; /* Border around message box */
        animation: fadeIn 0.5s ease-out; /* Fade in animation */
        max-width: 90%; /* Responsive width */
        box-sizing: border-box;
      }

      .message-box button {
        margin-top: 20px;
        padding: 10px 20px;
        font-size: 1em;
        background-color: #28a745; /* Green button for action */
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .message-box button:hover {
        background-color: #218838;
      }

      /* Animations */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translate(-50%, -60%);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%);
        }
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        h1 {
          font-size: 2em;
        }
        .game-info {
          font-size: 1em;
        }
        .game-button {
          padding: 14px 24px; /* Increased padding for better touch */
          font-size: 1em;
          min-height: 48px; /* Minimum touch target size */
          min-width: 120px;
        }
        .message-box {
          font-size: 1.2em;
          padding: 20px;
        }
        .touch-controls {
          margin-top: 40px; /* More space on smaller screens */
        }
        .touch-button {
          width: 70px;
          height: 70px;
          min-width: 70px;
          min-height: 70px;
          font-size: 28px;
        }
      }

      @media (max-width: 480px) {
        h1 {
          font-size: 1.8em;
        }
        .game-info {
          flex-direction: column;
          align-items: center;
          gap: 8px;
          font-size: 0.9em;
        }
        .game-button {
          width: 100%; /* Full width buttons on very small screens */
          padding: 16px;
          min-height: 52px;
          font-size: 1.1em;
        }
        .message-box {
          font-size: 1em;
          padding: 15px;
        }
        .touch-controls {
          margin-top: 50px;
          gap: 30px;
        }
        .touch-button {
          width: 80px;
          height: 80px;
          min-width: 80px;
          min-height: 80px;
          font-size: 32px;
        }
        /* Ensure safe areas for notched devices */
        .game-container {
          padding-left: env(safe-area-inset-left);
          padding-right: env(safe-area-inset-right);
        }
        .touch-controls {
          padding-left: calc(20px + env(safe-area-inset-left));
          padding-right: calc(20px + env(safe-area-inset-right));
          margin-top: calc(50px + env(safe-area-inset-bottom));
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>Breakout Game</h1>
      <div class="game-info">
        <span id="score">Score: 0</span>
      </div>
      <canvas id="gameCanvas"></canvas>
      <div class="controls">
        <button id="startButton" class="game-button">
          <i class="fas fa-play"></i> Start Game
        </button>
        <button id="restartButton" class="game-button" style="display: none">
          <i class="fas fa-redo"></i> Restart
        </button>
      </div>

      <!-- Touch controls for mobile -->
      <div class="touch-controls" id="touchControls">
        <button id="leftButton" class="touch-button touch-button-left">
          <i class="fas fa-chevron-left"></i>
        </button>
        <button id="rightButton" class="touch-button touch-button-right">
          <i class="fas fa-chevron-right"></i>
        </button>
      </div>
    </div>

    <!-- Custom message box for game over/win -->
    <div id="messageBox" class="message-box">
      <p id="messageText"></p>
      <button id="messageBoxButton">Play Again</button>
    </div>

    <script>
      // Get the canvas element and its 2D rendering context
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Get game info and control elements
      const scoreDisplay = document.getElementById("score");
      const startButton = document.getElementById("startButton");
      const restartButton = document.getElementById("restartButton");
      const messageBox = document.getElementById("messageBox");
      const messageText = document.getElementById("messageText");
      const messageBoxButton = document.getElementById("messageBoxButton");
      const touchControls = document.getElementById("touchControls");
      const leftButton = document.getElementById("leftButton");
      const rightButton = document.getElementById("rightButton");

      // Game variables
      let gameRunning = false;
      let animationFrameId;
      let lastFrameTime = 0;
      let targetFPS = 60;
      let frameCount = 0;
      let lastPerformanceCheck = 0;
      let slowFrameCount = 0;

      // Scaling variables for responsive design
      let scaleFactor = 1;
      let baseCanvasWidth = 800;
      let baseCanvasHeight = 600;

      // Enhanced game mechanics
      let baseBallSpeed = 4.5;
      let ballSpeed = 4.5;
      let currentLevel = 1;
      let comboCount = 0;
      let lastHitTime = 0;
      let particles = [];
      let speedMultiplier = 1;
      let maxSpeedMultiplier = 1.8;

      // Ball properties
      let baseBallRadius = 10;
      let ballRadius = 10;
      let x, y; // Ball position
      let dx, dy; // Ball speed and direction

      // Paddle properties
      let basePaddleHeight = 15;
      let basePaddleWidth = 100;
      let paddleHeight = 15;
      let paddleWidth = 100;
      let paddleX; // Paddle position

      // Brick properties
      let baseBrickRowCount = 6;
      let baseBrickColumnCount = 8;
      let brickRowCount = 6;
      let brickColumnCount = 8;
      let baseBrickWidth = 75;
      let baseBrickHeight = 20;
      let baseBrickPadding = 10;
      let baseBrickOffsetTop = 30;
      let baseBrickOffsetLeft = 30;
      let brickWidth = 75;
      let brickHeight = 20;
      let brickPadding = 10;
      let brickOffsetTop = 30;
      let brickOffsetLeft = 30;
      let bricks = []; // Array to store brick objects

      // Brick types with different properties
      const brickTypes = {
        normal: { color: '#ff6b6b', hits: 1, points: 10, powerUp: null },
        strong: { color: '#ff3838', hits: 2, points: 20, powerUp: null },
        bonus: { color: '#4ecdc4', hits: 1, points: 50, powerUp: 'bonus' },
        powerUp: { color: '#45b7d1', hits: 1, points: 30, powerUp: 'expand' },
        speedUp: { color: '#f9ca24', hits: 1, points: 25, powerUp: 'slow' }
      };

      // Power-up effects
      let activePowerUps = [];
      let powerUpDuration = 10000; // 10 seconds

      // Game state
      let score = 0;

      // Sound system
      let audioContext;
      let masterVolume = 0.3;
      let soundEnabled = true;

      /**
       * Initialize audio context for sound effects
       */
      function initAudio() {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.log('Web Audio API not supported:', e);
          soundEnabled = false;
        }
      }

      /**
       * Create a simple sound effect using Web Audio API
       */
      function playSound(type) {
        if (!soundEnabled || !audioContext) return;

        try {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          const currentTime = audioContext.currentTime;

          switch(type) {
            case 'paddle':
              oscillator.frequency.setValueAtTime(300, currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(200, currentTime + 0.1);
              gainNode.gain.setValueAtTime(masterVolume, currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.1);
              oscillator.start(currentTime);
              oscillator.stop(currentTime + 0.1);
              break;

            case 'brick':
              oscillator.frequency.setValueAtTime(500, currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(150, currentTime + 0.15);
              gainNode.gain.setValueAtTime(masterVolume * 0.7, currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.15);
              oscillator.start(currentTime);
              oscillator.stop(currentTime + 0.15);
              break;

            case 'powerup':
              oscillator.frequency.setValueAtTime(200, currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(800, currentTime + 0.2);
              gainNode.gain.setValueAtTime(masterVolume * 0.5, currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.2);
              oscillator.start(currentTime);
              oscillator.stop(currentTime + 0.2);
              break;

            case 'gameOver':
              oscillator.frequency.setValueAtTime(400, currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(100, currentTime + 0.5);
              gainNode.gain.setValueAtTime(masterVolume, currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.5);
              oscillator.start(currentTime);
              oscillator.stop(currentTime + 0.5);
              break;

            case 'levelComplete':
              oscillator.frequency.setValueAtTime(300, currentTime);
              oscillator.frequency.exponentialRampToValueAtTime(600, currentTime + 0.1);
              oscillator.frequency.exponentialRampToValueAtTime(900, currentTime + 0.2);
              gainNode.gain.setValueAtTime(masterVolume * 0.6, currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.3);
              oscillator.start(currentTime);
              oscillator.stop(currentTime + 0.3);
              break;

            case 'wall':
              oscillator.frequency.setValueAtTime(250, currentTime);
              gainNode.gain.setValueAtTime(masterVolume * 0.3, currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.05);
              oscillator.start(currentTime);
              oscillator.stop(currentTime + 0.05);
              break;
          }
        } catch (e) {
          console.log('Error playing sound:', e);
        }
      }

      /**
       * Toggle sound on/off
       */
      function toggleSound() {
        soundEnabled = !soundEnabled;
      }

      // Input handling
      let rightPressed = false;
      let leftPressed = false;
      let touchLeftPressed = false;
      let touchRightPressed = false;

      // Paddle physics variables
      let paddleVelocity = 0;
      let paddleAcceleration = 0.6 * scaleFactor;
      let paddleMaxSpeed = 15 * scaleFactor;
      let paddleDeceleration = 0.95; // Slight deceleration when no input
      let paddleTargetX;

      /**
       * Creates particle effects for visual feedback
       */
      function createParticles(x, y, color, count = 8) {
        for (let i = 0; i < count; i++) {
          particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 6 * scaleFactor,
            vy: (Math.random() - 0.5) * 6 * scaleFactor,
            life: 30,
            color: color,
            size: Math.random() * 4 + 2
          });
        }
      }

      /**
       * Updates and draws particles
       */
      function updateParticles() {
        particles = particles.filter(particle => {
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.vy += 0.2; // gravity
          particle.life--;

          if (particle.life > 0) {
            ctx.globalAlpha = particle.life / 30;
            ctx.fillStyle = particle.color;
            ctx.fillRect(particle.x, particle.y, particle.size * scaleFactor, particle.size * scaleFactor);
            ctx.globalAlpha = 1;
            return true;
          }
          return false;
        });
      }

      /**
       * Increases ball speed gently for kids
       */
      function increaseSpeed() {
        if (speedMultiplier < maxSpeedMultiplier) {
          speedMultiplier += 0.03; // Much gentler increase for kids
          const currentSpeed = Math.sqrt(dx * dx + dy * dy);
          const newSpeed = baseBallSpeed * scaleFactor * speedMultiplier;
          const angle = Math.atan2(dy, dx);
          dx = Math.cos(angle) * newSpeed;
          dy = Math.sin(angle) * newSpeed;
        }
      }

      /**
       * Calculates realistic ball deflection from paddle with gentle speed boost
       */
      function calculatePaddleDeflection(ballX) {
        const relativeIntersectX = (ballX - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
        const bounceAngle = relativeIntersectX * Math.PI / 3; // Max 60 degree angle

        // Very gentle speed increase for kids
        increaseSpeed();
        const speed = Math.sqrt(dx * dx + dy * dy) * 1.02; // Much gentler speed increase
        return {
          dx: speed * Math.sin(bounceAngle),
          dy: -Math.abs(speed * Math.cos(bounceAngle))
        };
      }

      /**
       * Updates combo and score with multiplier system
       */
      function updateCombo() {
        const currentTime = Date.now();
        if (currentTime - lastHitTime < 1000) { // Within 1 second
          comboCount++;
        } else {
          comboCount = 1;
        }
        lastHitTime = currentTime;
        return comboCount;
      }

      /**
       * Applies power-up effects
       */
      function applyPowerUp(type) {
        const powerUp = {
          type: type,
          endTime: Date.now() + powerUpDuration
        };

        // Apply immediate effect
        switch(type) {
          case 'expand':
            paddleWidth = basePaddleWidth * 1.5 * scaleFactor;
            createParticles(paddleX + paddleWidth/2, canvas.height - paddleHeight, '#45b7d1', 15);
            break;
          case 'slow':
            const currentSpeed = Math.sqrt(dx * dx + dy * dy);
            const newSpeed = currentSpeed * 0.7;
            const angle = Math.atan2(dy, dx);
            dx = Math.cos(angle) * newSpeed;
            dy = Math.sin(angle) * newSpeed;
            createParticles(x, y, '#f9ca24', 10);
            break;
          case 'bonus':
            score += 100;
            createParticles(canvas.width/2, canvas.height/2, '#4ecdc4', 20);
            break;
        }

        activePowerUps.push(powerUp);
      }

      /**
       * Updates and removes expired power-ups
       */
      function updatePowerUps() {
        const currentTime = Date.now();
        activePowerUps = activePowerUps.filter(powerUp => {
          if (currentTime > powerUp.endTime) {
            // Remove expired power-up effect
            switch(powerUp.type) {
              case 'expand':
                paddleWidth = basePaddleWidth * scaleFactor;
                break;
            }
            return false;
          }
          return true;
        });
      }

      /**
       * Updates the scale factor for responsive design
       */
      function updateScaleFactor() {
        const container = canvas.parentElement;
        const availableWidth = container.clientWidth - 40; // Subtract padding
        const availableHeight = window.innerHeight * 0.7; // Max 70% of viewport height

        // Calculate the best fit while maintaining aspect ratio
        const scaleX = availableWidth / baseCanvasWidth;
        const scaleY = availableHeight / baseCanvasHeight;
        scaleFactor = Math.min(scaleX, scaleY, 1.5); // Cap at 1.5x for very large screens

        // Adjust FPS for mobile performance
        if (scaleFactor < 0.8) {
          targetFPS = 50; // Lower FPS on smaller screens for better performance
        } else {
          targetFPS = 60;
        }
      }

      /**
       * Updates paddle physics with acceleration-based movement
       */
      function updatePaddlePhysics() {
        // Check if we're using mouse control or keyboard/touch control
        if (paddleTargetX !== undefined) {
          // Mouse control: smooth following
          const targetDiff = paddleTargetX - paddleX;
          paddleVelocity = targetDiff * 0.2; // Direct proportional control
        } else {
          // Keyboard/touch control: acceleration-based
          if (rightPressed || touchRightPressed) {
            // Accelerate while button is held
            paddleVelocity += paddleAcceleration;
          } else if (leftPressed || touchLeftPressed) {
            // Accelerate left while button is held
            paddleVelocity -= paddleAcceleration;
          } else {
            // No input: apply slight deceleration (not friction)
            paddleVelocity *= paddleDeceleration;

            // Stop completely if velocity is very small
            if (Math.abs(paddleVelocity) < 0.1) {
              paddleVelocity = 0;
            }
          }
        }

        // Limit to max speed
        paddleVelocity = Math.max(-paddleMaxSpeed, Math.min(paddleMaxSpeed, paddleVelocity));

        // Update paddle position
        let newX = paddleX + paddleVelocity;

        // Keep paddle within bounds (no bouncing)
        if (newX < 0) {
          newX = 0;
          paddleVelocity = 0; // Stop completely at left wall
        } else if (newX + paddleWidth > canvas.width) {
          newX = canvas.width - paddleWidth;
          paddleVelocity = 0; // Stop completely at right wall
        }

        paddleX = newX;
      }

      /**
       * Updates all game element dimensions based on scale factor
       */
      function updateScaledDimensions() {
        // Scale ball
        ballRadius = baseBallRadius * scaleFactor;

        // Scale paddle
        paddleHeight = basePaddleHeight * scaleFactor;
        paddleWidth = basePaddleWidth * scaleFactor;

        // Update paddle physics with new scale factor
        paddleAcceleration = 0.6 * scaleFactor;
        paddleMaxSpeed = 15 * scaleFactor;
        paddleVelocity = 0; // Reset velocity to prevent sudden movement on resize

        // Reset brick column count to base for responsive adjustments
        brickColumnCount = baseBrickColumnCount;
        brickRowCount = baseBrickRowCount;

        // Scale bricks with mobile-friendly sizing
        brickHeight = window.innerWidth < 768 ? (baseBrickHeight * 1.5) * scaleFactor : baseBrickHeight * scaleFactor;
        brickOffsetTop = baseBrickOffsetTop * scaleFactor;
        brickOffsetLeft = baseBrickOffsetLeft * scaleFactor;

        // Calculate brick dimensions to fill canvas width properly
        const availableBrickWidth = canvas.width - 2 * brickOffsetLeft;
        const totalPaddingWidth = (brickColumnCount - 1) * (baseBrickPadding * scaleFactor);

        // Calculate brick width to fill available space perfectly
        brickWidth = (availableBrickWidth - totalPaddingWidth) / brickColumnCount;
        brickPadding = baseBrickPadding * scaleFactor;

        // Ensure minimum brick width for playability with mobile-friendly sizing
        const minBrickWidth = window.innerWidth < 768 ? 50 * scaleFactor : 40 * scaleFactor;

        // Adjust brick layout for very small screens
        if (window.innerWidth < 480) {
          // Use fewer columns on very small screens
          const effectiveColumns = Math.floor(availableBrickWidth / minBrickWidth);
          if (effectiveColumns < brickColumnCount) {
            brickColumnCount = Math.max(effectiveColumns, 5); // Minimum 5 columns
          }
        }

        if (brickWidth < minBrickWidth) {
          brickWidth = minBrickWidth;
          // Recalculate padding to fit if bricks are at minimum size
          const usedBricksWidth = brickColumnCount * brickWidth;
          const remainingSpace = availableBrickWidth - usedBricksWidth;
          brickPadding = Math.max(remainingSpace / (brickColumnCount - 1), 8 * scaleFactor);
        }
      }

      /**
       * Initializes the game state.
       * Resets ball, paddle, bricks, score, and lives.
       */
      function initGame() {
        // Set canvas dimensions based on container width
        resizeCanvas();

        // Initial ball position and speed
        x = canvas.width / 2;
        y = canvas.height - 60 * scaleFactor; // Start higher to prevent immediate bottom collision
        // Set initial ball speed with kid-friendly physics
        speedMultiplier = 1;
        ballSpeed = baseBallSpeed * scaleFactor * 1.0; // Normal starting speed for kids
        const initialAngle = (Math.random() - 0.5) * Math.PI / 6; // Gentle angles for kids
        dx = Math.sin(initialAngle) * ballSpeed; // Horizontal speed
        dy = -Math.abs(Math.cos(initialAngle) * ballSpeed); // Always start moving upward

        // Initial paddle position and physics
        paddleX = (canvas.width - paddleWidth) / 2;
        paddleVelocity = 0;
        paddleTargetX = paddleX;

        // Initialize bricks array with varied types
        bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
          bricks[c] = [];
          for (let r = 0; r < brickRowCount; r++) {
            // Create varied brick layout based on row
            let type = 'normal';
            if (r === 0) {
              // Top row - strong bricks
              type = 'strong';
            } else if (r === 1 && Math.random() > 0.6) {
              // Second row - occasional power-ups
              type = 'powerUp';
            } else if (r === 2 && Math.random() > 0.7) {
              // Third row - occasional bonus bricks
              type = 'bonus';
            } else if (r === 3 && Math.random() > 0.8) {
              // Fourth row - occasional speed control
              type = 'speedUp';
            }

            const brickType = brickTypes[type];
            bricks[c][r] = {
              x: 0,
              y: 0,
              status: 1,
              type: type,
              hits: brickType.hits,
              maxHits: brickType.hits,
              color: brickType.color,
              points: brickType.points,
              powerUp: brickType.powerUp
            };
          }
        }

        // Reset game state
        score = 0;
        currentLevel = 1;
        comboCount = 0;
        lastHitTime = 0;
        particles = [];
        activePowerUps = [];
        ballSpeed = baseBallSpeed * scaleFactor;

        // Reset performance monitoring
        frameCount = 0;
        lastPerformanceCheck = 0;
        slowFrameCount = 0;
        targetFPS = 60;
        updateGameInfo(); // Update display
        gameRunning = false; // Game is paused initially
        messageBox.style.display = "none"; // Hide any previous messages
        startButton.style.display = "inline-flex"; // Show start button
        restartButton.style.display = "none"; // Hide restart button
      }

      /**
       * Resizes the canvas to fit its parent container and maintain a reasonable aspect ratio.
       */
      function resizeCanvas() {
        // Update scale factor first
        updateScaleFactor();

        // Set canvas dimensions based on scale factor
        canvas.width = baseCanvasWidth * scaleFactor;
        canvas.height = baseCanvasHeight * scaleFactor;

        // Update all scaled dimensions
        updateScaledDimensions();
      }

      /**
       * Updates the score display on the screen.
       */
      function updateGameInfo() {
        scoreDisplay.textContent = `Score: ${score}`;
      }

      /**
       * Draws the ball on the canvas.
       */
      function drawBall() {
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI * 2); // Draw a circle
        ctx.fillStyle = "#ffdd00"; // Yellow ball
        ctx.fill();
        ctx.closePath();
      }

      /**
       * Draws the paddle on the canvas.
       */
      function drawPaddle() {
        ctx.beginPath();
        ctx.rect(
          paddleX,
          canvas.height - paddleHeight,
          paddleWidth,
          paddleHeight
        ); // Draw a rectangle
        ctx.fillStyle = "#00c6ff"; // Blue paddle
        ctx.fill();
        ctx.closePath();
      }

      /**
       * Draws all visible bricks on the canvas with different types and effects.
       */
      function drawBricks() {
        for (let c = 0; c < brickColumnCount; c++) {
          for (let r = 0; r < brickRowCount; r++) {
            const brick = bricks[c][r];
            if (brick.status === 1) {
              // Calculate brick position
              const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
              const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
              brick.x = brickX;
              brick.y = brickY;

              ctx.beginPath();
              ctx.rect(brickX, brickY, brickWidth, brickHeight);

              // Set color based on brick type and damage
              ctx.fillStyle = brick.color;

              // Add visual effect for damaged strong bricks
              if (brick.type === 'strong' && brick.hits < brick.maxHits) {
                ctx.globalAlpha = 0.7;
              }

              // Add glow effect for special bricks
              if (brick.type === 'bonus' || brick.type === 'powerUp') {
                ctx.shadowBlur = 10 * scaleFactor;
                ctx.shadowColor = brick.color;
              }

              ctx.fill();
              ctx.closePath();
              ctx.globalAlpha = 1;
              ctx.shadowBlur = 0;

              // Draw hits remaining for strong bricks
              if (brick.type === 'strong' && brick.hits > 1) {
                ctx.fillStyle = '#ffffff';
                ctx.font = `${12 * scaleFactor}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(brick.hits, brickX + brickWidth / 2, brickY + brickHeight / 2 + 4 * scaleFactor);
              }

              // Draw icon for special bricks
              if (brick.powerUp) {
                ctx.fillStyle = '#ffffff';
                ctx.font = `${14 * scaleFactor}px FontAwesome`;
                ctx.textAlign = 'center';
                let icon = '';
                if (brick.powerUp === 'expand') icon = 'â†”';
                else if (brick.powerUp === 'bonus') icon = 'â˜…';
                else if (brick.powerUp === 'slow') icon = 'âš¡';
                ctx.fillText(icon, brickX + brickWidth / 2, brickY + brickHeight / 2 + 4 * scaleFactor);
              }
            }
          }
        }
      }

      /**
       * Enhanced collision detection with better physics and brick effects.
       */
      function collisionDetection() {
        let collisionCount = 0;
        const maxCollisionsPerFrame = 3; // Prevent multiple collisions in same frame

        for (let c = 0; c < brickColumnCount; c++) {
          for (let r = 0; r < brickRowCount; r++) {
            const brick = bricks[c][r];
            if (brick.status === 1) {
              // Enhanced collision detection
              const ballLeft = x - ballRadius;
              const ballRight = x + ballRadius;
              const ballTop = y - ballRadius;
              const ballBottom = y + ballRadius;

              const brickLeft = brick.x;
              const brickRight = brick.x + brickWidth;
              const brickTop = brick.y;
              const brickBottom = brick.y + brickHeight;

              if (ballRight > brickLeft && ballLeft < brickRight &&
                  ballBottom > brickTop && ballTop < brickBottom) {

                // Prevent infinite collision loops
                collisionCount++;
                if (collisionCount > maxCollisionsPerFrame) {
                  break; // Exit early to prevent game hanging
                }

                // Determine collision side for realistic physics
                const overlapLeft = ballRight - brickLeft;
                const overlapRight = brickRight - ballLeft;
                const overlapTop = ballBottom - brickTop;
                const overlapBottom = brickBottom - ballTop;

                const minOverlapX = Math.min(overlapLeft, overlapRight);
                const minOverlapY = Math.min(overlapTop, overlapBottom);

                // Apply damage to brick
                brick.hits--;
                if (brick.hits <= 0) {
                  brick.status = 0; // Mark brick as broken

                  // Calculate combo and score
                  const combo = updateCombo();
                  const points = brick.points * combo;
                  score += points;

                  // Play brick break sound
                  playSound('brick');

                  // Create particles for visual feedback
                  createParticles(brick.x + brickWidth/2, brick.y + brickHeight/2, brick.color, 12);

                  // Apply power-up if present
                  if (brick.powerUp) {
                    playSound('powerup'); // Play power-up sound
                    applyPowerUp(brick.powerUp);
                  }

                  // Check for win condition
                  const totalBricks = brickRowCount * brickColumnCount;
                  const remainingBricks = bricks.flat().filter(b => b.status === 1).length;
                  if (remainingBricks === 0) {
                    playSound('levelComplete'); // Play level complete sound
                    showMessage(`LEVEL ${currentLevel} COMPLETE! ðŸŽ‰ Score: ${score}`, true);
                    gameRunning = false;
                    cancelAnimationFrame(animationFrameId);
                  }
                } else {
                  // Brick damaged but not destroyed
                  createParticles(brick.x + brickWidth/2, brick.y + brickHeight/2, brick.color, 5);
                }

                updateGameInfo();

                // Realistic ball deflection based on collision side with speed boost
                if (minOverlapX < minOverlapY) {
                  // Side collision
                  dx = -dx;
                  // Increase speed slightly on brick hits
                  increaseSpeed();
                  // Adjust ball position to prevent getting stuck with buffer
                  if (overlapLeft < overlapRight) {
                    x = brickLeft - ballRadius - 1;
                  } else {
                    x = brickRight + ballRadius + 1;
                  }
                } else {
                  // Top/Bottom collision
                  dy = -dy;
                  // Increase speed slightly on brick hits
                  increaseSpeed();
                  // Adjust ball position to prevent getting stuck with buffer
                  if (overlapTop < overlapBottom) {
                    y = brickTop - ballRadius - 1;
                  } else {
                    y = brickBottom + ballRadius + 1;
                  }
                }
                return; // Exit after first collision to prevent multiple hits
              }
            }
          }
        }
      }

      /**
       * Main drawing function. Clears canvas and redraws all game elements with enhanced features.
       */
      function draw() {
        // Safety check for canvas context
        if (!ctx || !canvas) {
          console.error('Canvas context not available');
          gameRunning = false;
          return;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear entire canvas

        drawBricks();
        drawBall();
        drawPaddle();

        // Update game systems
        updateParticles();
        updatePowerUps();
        collisionDetection(); // Check collisions on each frame

        // Draw combo indicator
        if (comboCount > 1) {
          ctx.fillStyle = '#ffff00';
          ctx.font = `bold ${20 * scaleFactor}px Arial`;
          ctx.textAlign = 'center';
          ctx.fillText(`${comboCount}x COMBO!`, canvas.width / 2, 50 * scaleFactor);
        }

        // Draw active power-ups indicator
        if (activePowerUps.length > 0) {
          const powerUpTexts = activePowerUps.map(pu => {
            const timeLeft = Math.ceil((pu.endTime - Date.now()) / 1000);
            return `${pu.type.toUpperCase()}: ${timeLeft}s`;
          }).join(' | ');

          ctx.fillStyle = '#00ff00';
          ctx.font = `${14 * scaleFactor}px Arial`;
          ctx.textAlign = 'center';
          ctx.fillText(powerUpTexts, canvas.width / 2, canvas.height - 20 * scaleFactor);
        }

        
        // Ball movement and wall collision with improved boundary checking
        if (x + dx > canvas.width - ballRadius) {
          dx = -dx; // Reverse horizontal direction if hitting right wall
          x = canvas.width - ballRadius; // Keep ball inside bounds
          playSound('wall'); // Play wall hit sound
        } else if (x + dx < ballRadius) {
          dx = -dx; // Reverse horizontal direction if hitting left wall
          x = ballRadius; // Keep ball inside bounds
          playSound('wall'); // Play wall hit sound
        }
        if (y + dy < ballRadius) {
          dy = -dy; // Reverse vertical direction if hitting top wall
          y = ballRadius; // Keep ball inside bounds
          playSound('wall'); // Play wall hit sound
        } else if (y + dy > canvas.height - ballRadius - paddleHeight) {
          // Enhanced paddle collision detection
          const ballBottom = y + ballRadius;
          const paddleTop = canvas.height - paddleHeight;
          const paddleBottom = canvas.height;

          if (ballBottom >= paddleTop && x >= paddleX && x <= paddleX + paddleWidth) {
            // Ball hits paddle - use realistic physics
            const deflection = calculatePaddleDeflection(x);
            dx = deflection.dx;
            dy = deflection.dy;

            // Prevent ball from getting stuck in paddle with better positioning
            y = paddleTop - ballRadius - 1; // Add 1 pixel buffer

            // Ensure ball is moving upward after paddle hit
            if (dy > 0) {
              dy = -Math.abs(dy);
            }

            // Play paddle hit sound
            playSound('paddle');

            // Create impact effect
            createParticles(x, paddleTop, '#00c6ff', 3);

            // Reset combo if ball has been in play for a while
            const timeSinceLastHit = Date.now() - lastHitTime;
            if (timeSinceLastHit > 3000) {
              comboCount = 0;
            }
          } else if (ballBottom > paddleBottom) {
            // Ball hits bottom (misses paddle) - game over
            comboCount = 0; // Reset combo

            // Create game over effect
            createParticles(x, canvas.height - 20, '#ff0000', 15);

            // Play game over sound
            playSound('gameOver');

            // Show game over message
            showMessage(`GAME OVER! ðŸ’” Final Score: ${score}`, false);
            gameRunning = false;
            cancelAnimationFrame(animationFrameId); // Stop the game loop
          }
        }

        // Update paddle physics with realistic movement
        updatePaddlePhysics();

        // Update ball position
        x += dx; // Update ball x position
        y += dy; // Update ball y position
      }

      /**
       * The main game loop. Calls draw function repeatedly using requestAnimationFrame with frame rate limiting.
       */
      function gameLoop(currentTime) {
        if (gameRunning) {
          try {
            // Performance monitoring - check every 2 seconds
            frameCount++;
            if (currentTime - lastPerformanceCheck > 2000) {
              const fps = frameCount / ((currentTime - lastPerformanceCheck) / 1000);
              if (fps < 30) {
                slowFrameCount++;
                // Reduce target FPS if consistently slow
                if (slowFrameCount > 3 && targetFPS > 30) {
                  targetFPS = Math.max(30, targetFPS - 10);
                  console.log('Reducing target FPS to:', targetFPS);
                }
              } else {
                slowFrameCount = 0; // Reset counter if performance is good
              }
              frameCount = 0;
              lastPerformanceCheck = currentTime;
            }

            // Frame rate limiting for better performance on mobile
            if (currentTime - lastFrameTime >= 1000 / targetFPS) {
              draw();
              lastFrameTime = currentTime;
            }
            animationFrameId = requestAnimationFrame(gameLoop);
          } catch (error) {
            console.error('Game loop error:', error);
            // Emergency game state reset
            gameRunning = false;
            showMessage('Game encountered an error. Please restart.', false);
            if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
            }
          }
        }
      }

      /**
       * Displays a message box with game status (win/lose) and a play again button.
       * @param {string} message - The message to display.
       * @param {boolean} isWin - True if the game was won, false otherwise.
       */
      function showMessage(message, isWin) {
        messageText.textContent = message;
        messageBoxButton.textContent = "Play Again";
        messageBox.style.display = "block";
        if (isWin) {
          messageBoxButton.style.backgroundColor = "#28a745"; // Green for win
        } else {
          messageBoxButton.style.backgroundColor = "#dc3545"; // Red for lose
        }
      }

      // Event Listeners for Keyboard Input
      document.addEventListener("keydown", (e) => {
        if (e.key === "Right" || e.key === "ArrowRight") {
          rightPressed = true;
          paddleTargetX = undefined; // Clear mouse target to prevent conflicts
        } else if (e.key === "Left" || e.key === "ArrowLeft") {
          leftPressed = true;
          paddleTargetX = undefined; // Clear mouse target to prevent conflicts
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.key === "Right" || e.key === "ArrowRight") {
          rightPressed = false;
        } else if (e.key === "Left" || e.key === "ArrowLeft") {
          leftPressed = false;
        }
      });

      // Event Listeners for Touch Input (for paddle movement)
      let touchStartX = 0;
      let paddleStartTouchX = 0;

      canvas.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault(); // Prevent scrolling
          if (e.touches.length > 0) {
            touchStartX = e.touches[0].clientX;
            paddleStartTouchX = paddleX;
            paddleTargetX = undefined; // Clear mouse target to prevent conflicts
          }
        },
        { passive: false }
      ); // Set passive to false to allow preventDefault

      canvas.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault(); // Prevent scrolling
          if (e.touches.length > 0) {
            const touchCurrentX = e.touches[0].clientX;
            const touchDeltaX = touchCurrentX - touchStartX;

            // Use acceleration-based movement instead of direct position setting
            if (touchDeltaX > 20) {
              touchRightPressed = true;
              touchLeftPressed = false;
            } else if (touchDeltaX < -20) {
              touchLeftPressed = true;
              touchRightPressed = false;
            } else {
              touchLeftPressed = false;
              touchRightPressed = false;
            }
          }
        },
        { passive: false }
      );

      canvas.addEventListener("touchend", () => {
        // Clear touch input when touch ends
        touchLeftPressed = false;
        touchRightPressed = false;
      });

      // Handle mouse movement for paddle control with physics
      canvas.addEventListener("mousemove", (e) => {
        const relativeX = e.clientX - canvas.getBoundingClientRect().left;
        if (relativeX > 0 && relativeX < canvas.width) {
          // Set target position for smooth following
          paddleTargetX = relativeX - paddleWidth / 2;
          // Clamp to canvas boundaries
          paddleTargetX = Math.max(0, Math.min(canvas.width - paddleWidth, paddleTargetX));
        }
      });

      // Start Button Handler
      startButton.addEventListener("click", () => {
        if (!gameRunning) {
          gameRunning = true;
          startButton.style.display = "none"; // Hide start button
          restartButton.style.display = "inline-flex"; // Show restart button
          gameLoop(); // Start the game loop
        }
      });

      // Restart Button Handler
      restartButton.addEventListener("click", () => {
        cancelAnimationFrame(animationFrameId); // Stop current loop if running
        initGame(); // Re-initialize game state
        gameRunning = true; // Set game to running
        startButton.style.display = "none"; // Hide start button
        restartButton.style.display = "inline-flex"; // Show restart button
        gameLoop(); // Start new game loop
      });

      // Touch button event handlers
      function handleTouchStart(button, direction) {
        return (e) => {
          e.preventDefault();
          paddleTargetX = undefined; // Clear mouse target to prevent conflicts
          button.classList.add('active'); // Add visual feedback
          if (direction === 'left') {
            touchLeftPressed = true;
          } else {
            touchRightPressed = true;
          }
        };
      }

      function handleTouchEnd(button, direction) {
        return (e) => {
          e.preventDefault();
          button.classList.remove('active'); // Remove visual feedback
          if (direction === 'left') {
            touchLeftPressed = false;
          } else {
            touchRightPressed = false;
          }
        };
      }

      // Left button touch events
      leftButton.addEventListener("touchstart", handleTouchStart(leftButton, 'left'), { passive: false });
      leftButton.addEventListener("touchend", handleTouchEnd(leftButton, 'left'), { passive: false });
      leftButton.addEventListener("touchcancel", handleTouchEnd(leftButton, 'left'), { passive: false });
      leftButton.addEventListener("mousedown", handleTouchStart(leftButton, 'left'));
      leftButton.addEventListener("mouseup", handleTouchEnd(leftButton, 'left'));
      leftButton.addEventListener("mouseleave", handleTouchEnd(leftButton, 'left'));

      // Right button touch events
      rightButton.addEventListener("touchstart", handleTouchStart(rightButton, 'right'), { passive: false });
      rightButton.addEventListener("touchend", handleTouchEnd(rightButton, 'right'), { passive: false });
      rightButton.addEventListener("touchcancel", handleTouchEnd(rightButton, 'right'), { passive: false });
      rightButton.addEventListener("mousedown", handleTouchStart(rightButton, 'right'));
      rightButton.addEventListener("mouseup", handleTouchEnd(rightButton, 'right'));
      rightButton.addEventListener("mouseleave", handleTouchEnd(rightButton, 'right'));

      // Prevent touch scroll on the buttons
      leftButton.addEventListener("touchmove", (e) => e.preventDefault(), { passive: false });
      rightButton.addEventListener("touchmove", (e) => e.preventDefault(), { passive: false });

      // Message Box Button Handler (for Play Again)
      messageBoxButton.addEventListener("click", () => {
        cancelAnimationFrame(animationFrameId); // Stop current loop if running
        initGame(); // Re-initialize game state
        // Game will be started by the startButton click after init, or directly if gameRunning is true
        // if we are coming from a win/lose state, we want to allow user to press Start again.
        // But if it was a mid-game pause, we just restart the game.
        if (
          messageText.textContent.includes("GAME OVER") ||
          messageText.textContent.includes("You WIN")
        ) {
          startButton.style.display = "inline-flex";
          restartButton.style.display = "none";
        } else {
          // This else block might not be hit with current logic but good for future proofing
          gameRunning = true;
          startButton.style.display = "none";
          restartButton.style.display = "inline-flex";
          gameLoop();
        }
        messageBox.style.display = "none"; // Hide the message box
      });

      // Initialize game on window load
      window.onload = function () {
        initAudio(); // Initialize audio system
        initGame(); // Initialize game state

        // Add event listener for window resize to make the canvas responsive
        window.addEventListener("resize", () => {
          resizeCanvas();
          // Re-center paddle and ball after resize
          paddleX = (canvas.width - paddleWidth) / 2;
          x = canvas.width / 2;
          y = canvas.height - 30 * scaleFactor;
          // If game is running, redraw immediately
          if (gameRunning) {
            draw();
          } else {
            // If game is paused, clear and draw initial state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPaddle();
            drawBall();
            drawBricks();
          }
        });

        // Handle orientation changes for mobile devices
        window.addEventListener("orientationchange", () => {
          setTimeout(() => {
            resizeCanvas();
            // Re-center paddle and ball after orientation change
            paddleX = (canvas.width - paddleWidth) / 2;
            x = canvas.width / 2;
            y = canvas.height - 30 * scaleFactor;
            // Redraw the game
            if (gameRunning) {
              draw();
            } else {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              drawPaddle();
              drawBall();
              drawBricks();
            }
          }, 100); // Small delay to allow the browser to update layout
        });

        // Prevent zoom on double tap for mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
          const now = (new Date()).getTime();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        }, false);

        // Initial draw to show elements before game starts
        drawPaddle();
        drawBall();
        drawBricks();
      };
    </script>

    <!-- KidsGames PWA Service Worker -->
    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/KidsGames/sw.js")
            .then((registration) => {
              console.log("[PWA] Service Worker registered for free game");
            })
            .catch((error) => {
              console.log("[PWA] Service Worker registration failed:", error);
            });
        });
      }
    </script>
  </body>
</html>
